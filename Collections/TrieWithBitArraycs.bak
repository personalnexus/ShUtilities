using System;
using System.Collections;
using System.Collections.Generic;

namespace ShUtilities.Collections
{
    public class Trie<TValue>: IDictionary<string, TValue>
    {
        public Trie(ISet<char> possibleCharacters, int initialCapacity, int capacityIncrement)
        {
            int index = 1;
            foreach (char character in possibleCharacters)
            {
                if (_keyIndexByCharacter == null || character >= _keyIndexByCharacter.Length)
                {
                    Array.Resize(ref _keyIndexByCharacter, character + 1);
                }
                _keyIndexByCharacter[character] = index;
                index++;
            }
            _capacityIncrement = capacityIncrement;
            _possibleCharacterCount = possibleCharacters.Count;
            _isValueSet = new BitArray(initialCapacity);
            Resize(initialCapacity);
        }

        // Key lookup

        private int[] _keyIndexByCharacter;

        // Nodes

        private TValue[] _values;
        private BitArray _isValueSet;
        private int[] _indexes;
        private int _lastUsedIndex;

        private readonly int _possibleCharacterCount;
        private readonly int _capacityIncrement;

        private ref TValue Get(string key, bool createIfMissing, out int index)
        {
            index = 0;
            foreach (char character in key)
            {
                // Step 1: get the index of where in the _indexes array the index into _nodes is found
                int indexIndex = (index * _possibleCharacterCount) + _keyIndexByCharacter[character];
                // Step 2: get the index of the value in _values
                index = _indexes[indexIndex];
                if (index == 0)
                {
                    if (createIfMissing)
                    {
                        _lastUsedIndex++;
                        if (_lastUsedIndex == _values.Length)
                        {
                            Resize(_values.Length + _capacityIncrement);
                        }
                        index = _indexes[indexIndex] = _lastUsedIndex;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            return ref _values[index];
        }

        private void Resize(int newSize)
        {
            _isValueSet.Length = newSize;
            Array.Resize(ref _values, newSize);
            Array.Resize(ref _indexes, newSize * _possibleCharacterCount);
        }

        // IDictionary<string, TValue>

        public ICollection<string> Keys => throw new NotImplementedException();

        public ICollection<TValue> Values => throw new NotImplementedException();

        public int Count { get; private set; }

        public bool IsReadOnly { get; set; }

        public TValue this[string key]
        {
            get
            {
                if (!TryGetValue(key, out TValue value))
                {
                    throw new KeyNotFoundException($"Key {key} does not exist.");
                }
                return value;
            }
            set
            {
                SetValue(key, value, false);
            }
        }

        public void Add(KeyValuePair<string, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        public void Add(string key, TValue value)
        {
            SetValue(key, value, true);
        }

        private void SetValue(string key, TValue value, bool throwIfKeyExists)
        {
            ref TValue existingValue = ref Get(key, true, out int index);
            if (!_isValueSet[index])
            {
                _isValueSet[index] = true;
                Count++;
            }
            else if (throwIfKeyExists)
            {
                throw new ArgumentException($"Key {key} already exists.");
            }
            existingValue = value;
        }

        public void Clear()
        {
            CheckReadOnly();
            _values = new TValue[1];
            _indexes = new int[_possibleCharacterCount];
            _lastUsedIndex = 0;
            Count = 0;
        }

        public bool ContainsKey(string key)
        {
            Get(key, false, out int index);
            bool result = _isValueSet[index];
            return result;
        }

        public bool Contains(KeyValuePair<string, TValue> item)
        {
            return ContainsKey(item.Key);
        }

        public void CopyTo(KeyValuePair<string, TValue>[] array, int arrayIndex)
        {
            throw new NotImplementedException();
        }

        public bool Remove(KeyValuePair<string, TValue> item)
        {
            return Remove(item.Key);
        }

        public bool Remove(string key)
        {
            CheckReadOnly();
            ref TValue value = ref Get(key, false, out int index);
            bool result = _isValueSet[index];
            if (result)
            {
                Count--;
                value = default;
                _isValueSet[index] = false;
            }
            return result;
        }

        public bool TryGetValue(string key, out TValue value)
        {
            value = Get(key, false, out int index);
            return _isValueSet[index];
        }

        public IEnumerator<KeyValuePair<string, TValue>> GetEnumerator()
        {
            throw new NotImplementedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        private void CheckReadOnly()
        {
            if (IsReadOnly)
            {
                throw new InvalidOperationException("Trie is read-only.");
            }
        }

        // TrieInfo

        public TrieInfo GetInfo()
        {
            var result = new TrieInfo
            {
                Count = Count,
                IndexSize = _indexes.Length * sizeof(int),
                NodesSize = _values.Length * (sizeof(bool) + System.Runtime.InteropServices.Marshal.SizeOf<TValue>()),
                LookupSize = _keyIndexByCharacter.Length * sizeof(int)
            };
            return result;
        }
    }
}